<HTML>
<HEAD>
   <TITLE> module bianchi_sky_mod (generated by f90doc) </TITLE>
  <LINK rel="stylesheet" href="stylesheet.css" type="text/css" /> </HEAD>
<H1> Module bianchi_sky_mod </H1>
<PRE>module bianchi_sky_mod

        ! Uses
    use <A HREF="s2_types_mod.html">s2_types_mod</A>
    use <A HREF="s2_sky_mod.html">s2_sky_mod</A>
    use <A HREF="s2_error_mod.html">s2_error_mod</A>
    use <A HREF="bianchi_error_mod.html">bianchi_error_mod</A>

        ! Types
    public type <A HREF="bianchi_sky_mod.html#type_bianchi_sky">bianchi_sky</A>

        ! Variables
    integer, public, parameter :: <A HREF="bianchi_sky_mod.html#var_bianchi_sky_quad_direct">BIANCHI_SKY_QUAD_DIRECT</A> = 1
    integer, public, parameter :: <A HREF="bianchi_sky_mod.html#var_bianchi_sky_quad_qtrap">BIANCHI_SKY_QUAD_QTRAP</A> = 2
    integer, public, parameter :: <A HREF="bianchi_sky_mod.html#var_bianchi_sky_quad_qsimp">BIANCHI_SKY_QUAD_QSIMP</A> = 3
    logical, private, parameter :: <A HREF="bianchi_sky_mod.html#var_bianchi_disable_plm1table">BIANCHI_DISABLE_PLM1TABLE</A> = .false.
    real (kind=s2_dp), private, parameter :: <A HREF="bianchi_sky_mod.html#var_bianchi_cmb_t">BIANCHI_CMB_T</A> = 1d0

        ! Subroutines and functions
    public function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_init">bianchi_sky_init</A> (omega0, x, zE, s12H, s13H, rhand, nside, quad, N) result (b)
    public function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_init_alm">bianchi_sky_init_alm</A> (omega0, x, zE, s12H, s13H, rhand, lmax, quad_AB, quad_IAB, N, alpha, beta, gamma) result (b)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_free">bianchi_sky_free</A> (b)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_param_write">bianchi_sky_param_write</A> (b)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_compute_map">bianchi_sky_compute_map</A> (b, nside)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_compute_alm">bianchi_sky_compute_alm</A> (b, lmax, mmax)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_get_alm">bianchi_sky_get_alm</A> (b, alm)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_apply_beam">bianchi_sky_apply_beam</A> (b, fwhm, lmax)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_write">bianchi_sky_write</A> (b, filename, file_type, comment)
    public subroutine <A HREF="bianchi_sky_mod.html#subroutine_bianchi_sky_rotate">bianchi_sky_rotate</A> (b, alpha, beta, gamma)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_s">bianchi_sky_comp_s</A> (tau, tau0, theta0, h) result (s)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_psi">bianchi_sky_comp_psi</A> (tau, tau0, theta0, h) result (psi)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_c1">bianchi_sky_comp_c1</A> (omega0, x) result (c1)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_c2">bianchi_sky_comp_c2</A> (sE, zE) result (c2)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_c3">bianchi_sky_comp_c3</A> (omega0, h) result (c3)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_a">bianchi_sky_comp_A</A> (theta, tauE, tau0, h, zE, c1, c3, quad, N) result (Atheta)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_b">bianchi_sky_comp_B</A> (theta, tauE, tau0, h, zE, c1, c3, quad, N) result (Btheta)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_ia">bianchi_sky_comp_IA</A> (tauE, tau0, h, zE, c1, c3, l, quad_AB, quad_IAB, N, A_grid) result (IA)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_comp_ib">bianchi_sky_comp_IB</A> (tauE, tau0, h, zE, c1, c3, l, quad_AB, quad_IAB, N, B_grid) result (IB)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_integrand_a">bianchi_sky_integrand_A</A> (tau, tau0, theta0, h) result (integrand)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_integrand_b">bianchi_sky_integrand_B</A> (tau, tau0, theta0, h) result (integrand)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_integrand_ia">bianchi_sky_integrand_IA</A> (theta, tauE, tau0, h, zE, c1, c3, l, quad_AB, N, A_grid) result (integrand)
    private function <A HREF="bianchi_sky_mod.html#function_bianchi_sky_integrand_ib">bianchi_sky_integrand_IB</A> (theta, tauE, tau0, h, zE, c1, c3, l, quad_AB, N, B_grid) result (integrand)
    private subroutine <A HREF="bianchi_sky_mod.html#subroutine_trapzd_a">trapzd_a</A> (func, tau0, theta0, h, a, b, s, n)
    private function <A HREF="bianchi_sky_mod.html#function_qtrap_a">qtrap_a</A> (func, tau0, theta0, h, a, b) result (integral)
    private function <A HREF="bianchi_sky_mod.html#function_qsimp_a">qsimp_a</A> (func, tau0, theta0, h, a, b) result (integral)
    private subroutine <A HREF="bianchi_sky_mod.html#subroutine_trapzd_ia">trapzd_ia</A> (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, s, n, N_quad)
    private function <A HREF="bianchi_sky_mod.html#function_qtrap_ia">qtrap_ia</A> (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, N_quad) result (integral)
    private function <A HREF="bianchi_sky_mod.html#function_qsimp_ia">qsimp_ia</A> (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, N_quad) result (integral)
    private function <A HREF="bianchi_sky_mod.html#function_plgndr">plgndr</A> (l, m, x)
    private function <A HREF="bianchi_sky_mod.html#function_asinh">asinh</A> (x) result (y)

end module bianchi_sky_mod
</PRE>
 Provides functionality to simulate a Bianchi VII_h model of the CMB.
 Uses the s2_sky module to create healpix sky maps.
<P>
<STRONG>Author:</STRONG> J. D. McEwen (mcewen@mrao.cam.ac.uk)
<P>
<STRONG>Version:</STRONG> 0.1 June 2005

<HR><H2> Description of Types </H2>
<A NAME="type_bianchi_sky"><H3>bianchi_sky</H3></A>
<PRE>public type bianchi_sky
    private
    logical :: init = .false.
    real (kind=s2_dp) :: omega0 = 0.0d0
    real (kind=s2_dp) :: x = 0.0d0
    real (kind=s2_dp) :: zE = 0.0d0
    real (kind=s2_dp) :: s12H = 0.0d0
    real (kind=s2_dp) :: s13H = 0.0d0
    logical :: rhand = .true.
    real (kind=s2_dp) :: wH = 0.0d0
    real (kind=s2_dp) :: h = 0.0d0
    real (kind=s2_dp) :: tau0 = 0.0d0
    real (kind=s2_dp) :: tauE = 0.0d0
    type (s2_sky) :: sky
end type bianchi_sky
</PRE>
 <UL>
 <LI>  init: Initialisation status.
 <LI>  omega0: Density (input parameter).
 <LI>  x: Related to characteristic wavelength over which basis vectors 
   change orientation (input parameter).
 <LI>  zE: Red shift (input parameter).
 <LI>  s12H: Normalised shear 12 (normalised to Hubble constant)
   (input parameter).
 <LI>  s13H: Normalised shear 13 (normalised to Hubble constant) 
   (input parameter).
 <LI>  rhand: Logical specifying handedness of map (true=right).
 <LI>  wH: Normalised vorticity (normalised to Hubble constant).
 <LI>  h: Related to characteristic wavelength over which basis vectors 
   change orientation.
 <LI>  tau0: Conformal time of photon reception.
 <LI>  tauE: Conformal time of photon emission.
 <LI>  sky: Simulated map.
 </UL>

<HR><H2> Description of Variables </H2>
<A NAME="var_bianchi_sky_quad_direct"><H3>BIANCHI_SKY_QUAD_DIRECT</H3></A>
<PRE>integer, public, parameter :: BIANCHI_SKY_QUAD_DIRECT = 1
</PRE>
 Quadrature type: Direct (rectangular).
<A NAME="var_bianchi_sky_quad_qtrap"><H3>BIANCHI_SKY_QUAD_QTRAP</H3></A>
<PRE>integer, public, parameter :: BIANCHI_SKY_QUAD_QTRAP = 2
</PRE>
 Quadrature type: Trapezium rule.
<A NAME="var_bianchi_sky_quad_qsimp"><H3>BIANCHI_SKY_QUAD_QSIMP</H3></A>
<PRE>integer, public, parameter :: BIANCHI_SKY_QUAD_QSIMP = 3
</PRE>
 Quadrature type: Simpson's rule.
<A NAME="var_bianchi_disable_plm1table"><H3>BIANCHI_DISABLE_PLM1TABLE</H3></A>
<PRE>logical, private, parameter :: BIANCHI_DISABLE_PLM1TABLE = .false.
</PRE>
<A NAME="var_bianchi_cmb_t"><H3>BIANCHI_CMB_T</H3></A>
<PRE>real (kind=s2_dp), private, parameter :: BIANCHI_CMB_T = 1d0
</PRE>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="function_bianchi_sky_init"><H3>bianchi_sky_init</H3></A>
<PRE>public function bianchi_sky_init (omega0, x, zE, s12H, s13H, rhand, nside, quad, N) result (b)
    real (kind=s2_dp), intent(in) :: omega0
    real (kind=s2_dp), intent(in) :: x
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: s12H
    real (kind=s2_dp), intent(in) :: s13H
    logical, intent(in) :: rhand
    integer, intent(in) :: nside
    integer, intent(in) :: quad
    integer, optional, intent(in) :: N
    type (bianchi_sky) :: b
    ! Calls: bianchi_error, in_ring, pix2ang_ring
end function bianchi_sky_init
</PRE>
 Initialise bianchi object by performing a bianchi simulation, computed
 in real space, with the specified parameters.
<P>
 Variables:
  <UL>
  <LI>  omega0: Input omega0 parameter (see bianchi data type for
    explanation).
  <LI>  x: Input x parameter (see bianchi data type for explanation).
  <LI>  zE: Input zE parameter (see bianchi data type for explanation).
  <LI>  s12H: Input s12H parameter (see bianchi data type for explanation).
  <LI>  s13H: Input s13H parameter (see bianchi data type for explanation).
  <LI>  rhand: Logical to specify handedness of map.
  <LI>  nside: Nside of Healpix map to generate.
  <LI>  quad: Quadrature rule to use.
  <LI>  [N]: Resolution of numerical integration (number of terms used to
    evaluate integral).  If not specified default of 10 is used.
  <LI>  b: Initialised bianchi object with all parameters and simulated
    map calculated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_init_alm"><H3>bianchi_sky_init_alm</H3></A>
<PRE>public function bianchi_sky_init_alm (omega0, x, zE, s12H, s13H, rhand, lmax, quad_AB, quad_IAB, N, alpha, beta, gamma) result (b)
    real (kind=s2_dp), intent(in) :: omega0
    real (kind=s2_dp), intent(in) :: x
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: s12H
    real (kind=s2_dp), intent(in) :: s13H
    logical, intent(in) :: rhand
    integer, intent(in) :: lmax
    integer, intent(in) :: quad_AB
    integer, intent(in) :: quad_IAB
    integer, optional, intent(in) :: N
    real (kind=s2_sp), optional, intent(in) :: alpha
    real (kind=s2_sp), optional, intent(in) :: beta
    real (kind=s2_sp), optional, intent(in) :: gamma
    type (bianchi_sky) :: b
    ! Calls: bianchi_error, s2_dl_beta_operator
end function bianchi_sky_init_alm
</PRE>
 Initialise bianchi object by performing a bianchi simulation, computed
 in harmonic space, with the specified parameters.
<P>
 Notes:
   <UL>
   <LI>  Uses lookup table for Plms for N=100, quad_IA=direct.
<P>
   </UL>
 Variables:
  <UL>
  <LI>  omega0: Input omega0 parameter (see bianchi data type for
    explanation).
  <LI>  x: Input x parameter (see bianchi data type for explanation).
  <LI>  zE: Input zE parameter (see bianchi data type for explanation).
  <LI>  s12H: Input s12H parameter (see bianchi data type for explanation).
  <LI>  s13H: Input s13H parameter (see bianchi data type for explanation).
  <LI>  rhand: Logical to specify handedness of map.
  <LI>  nside: Nside of Healpix map to generate.
  <LI>  lmax: Maximum harmonic l to compute alms up to.
  <LI>  quad_AB: Quadrature rule to use for AB integration.
  <LI>  quad_IAB: Quadrature rule to use for IAB integration.
  <LI>  [N]: Resolution of numerical integration (number of terms used to
    evaluate integral).  If not specified default of 10 is used.
  <LI>  [beam_fwhm]: Full-width-half-maximum of Gaussian beam to apply.
    If not present then no beam is applied.
    (Must be specified in arcmin.)
  <LI>  b: Initialised bianchi object with all parameters and simulated
    map calculated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_bianchi_sky_free"><H3>bianchi_sky_free</H3></A>
<PRE>public subroutine bianchi_sky_free (b)
    type (bianchi_sky), intent(inout) :: b
    ! Calls: bianchi_error, s2_sky_free
end subroutine bianchi_sky_free
</PRE>
 Free all memory associated with a bianchi object.
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object to free.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="subroutine_bianchi_sky_param_write"><H3>bianchi_sky_param_write</H3></A>
<PRE>public subroutine bianchi_sky_param_write (b)
    type (bianchi_sky), intent(in) :: b
end subroutine bianchi_sky_param_write
</PRE>
 Write parameters of the Bianchi simulation to standard output.
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object containing parameter atrtributes to write.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="subroutine_bianchi_sky_compute_map"><H3>bianchi_sky_compute_map</H3></A>
<PRE>public subroutine bianchi_sky_compute_map (b, nside)
    type (bianchi_sky), intent(inout) :: b
    integer, intent(in) :: nside
    ! Calls: bianchi_error, s2_sky_compute_map
end subroutine bianchi_sky_compute_map
</PRE>
 Compute the map of the bianchi sky, assuming the alms are already
 defined.
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object containing alms to compute map of.
  <LI>  nside: Healpix nside to compute map at.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_bianchi_sky_compute_alm"><H3>bianchi_sky_compute_alm</H3></A>
<PRE>public subroutine bianchi_sky_compute_alm (b, lmax, mmax)
    type (bianchi_sky), intent(inout) :: b
    integer, intent(in) :: lmax
    integer, intent(in) :: mmax
    ! Calls: bianchi_error, s2_sky_compute_alm
end subroutine bianchi_sky_compute_alm
</PRE>
 Compute the alm of the bianchi sky, assuming the map is already
 defined.
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object containing sky to compute alms of.
  <LI>  lmax: Maximum harmonic l to consider when computing alms.
  <LI>  mmax: Maximum harmonic m to consider when computing alms.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_bianchi_sky_get_alm"><H3>bianchi_sky_get_alm</H3></A>
<PRE>public subroutine bianchi_sky_get_alm (b, alm)
    type (bianchi_sky), intent(in) :: b
    complex (kind=s2_spc), intent(out), dimension (:,:) :: alm
    ! Calls: bianchi_error, s2_sky_get_alm
end subroutine bianchi_sky_get_alm
</PRE>
 Get alms contained in a bianchi sky object.  Alms must already be
 computed.
<P>
 Notes:
   <UL>
   <LI>  Error occurs if alms are not already computed.
<P>
   </UL>
 Variables:
   <UL>
   <LI>  b: Bianchi object containing sky that in turn contained the alms
     to get.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_bianchi_sky_apply_beam"><H3>bianchi_sky_apply_beam</H3></A>
<PRE>public subroutine bianchi_sky_apply_beam (b, fwhm, lmax)
    type (bianchi_sky), intent(inout) :: b
    real (kind=s2_sp), intent(in) :: fwhm
    integer, intent(in) :: lmax
    ! Calls: s2_pl_free, s2_sky_conv
end subroutine bianchi_sky_apply_beam
</PRE>
 Apply Gaussian beam with specified FWHM.  (FWHM must be passed in
 arcmin.)
<P>
 Notes:
   <UL>
   <LI>  Error occurs if alms are not already computed.
<P>
   </UL>
 Variables:
   <UL>
   <LI>  b: Bianchi object containing sky that is to be comvolved with
     the beam.
   <LI>  fwhm: Gaussian beam FWHM to use (specified in arcmin).
   <LI>  lmax: Maximum harmonic l to consider.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_bianchi_sky_write"><H3>bianchi_sky_write</H3></A>
<PRE>public subroutine bianchi_sky_write (b, filename, file_type, comment)
    type (bianchi_sky), intent(inout) :: b
    character (len=*), intent(in) :: filename
    integer, intent(in) :: file_type
    character (len=*), optional, intent(in) :: comment
    ! Calls: bianchi_error, s2_error, s2_sky_io_fits_write, s2_sky_write_map_file
end subroutine bianchi_sky_write
</PRE>
 Write the bianchi simulated sky to a file. 
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object to save sky of.
  <LI>  filename: Name of output file.
  <LI>  file_type: Type of output file, either fits map or sky file 
    (see s2_sky_mod for more details).  Integer flag that may be 
    either S2_SKY_FILE_TYPE_MAP or S2_SKY_FILE_TYPE_SKY.
  <LI>  [comment]: Optional comment to append to file header.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="subroutine_bianchi_sky_rotate"><H3>bianchi_sky_rotate</H3></A>
<PRE>public subroutine bianchi_sky_rotate (b, alpha, beta, gamma)
    type (bianchi_sky), intent(inout) :: b
    real (kind=s2_sp) :: alpha
    real (kind=s2_sp) :: beta
    real (kind=s2_sp) :: gamma
    ! Calls: bianchi_error, s2_sky_rotate
end subroutine bianchi_sky_rotate
</PRE>
 Rotate the simulated sky of the bianchi object.  
<P>
 Variables:
  <UL>
  <LI>  b: Bianchi object containing sky to be rotated.
  <LI>  alpha: Alpha Euler angle of the rotation.
  <LI>  beta: Beta Euler angle of the rotation.
  <LI>  gamma: Gamma Euler angle of the rotation.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_s"><H3>bianchi_sky_comp_s</H3></A>
<PRE>private function bianchi_sky_comp_s (tau, tau0, theta0, h) result (s)
    real (kind=s2_dp), intent(in) :: tau
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp) :: s
end function bianchi_sky_comp_s
</PRE>
 Compute s variable in bianchi sky simulation. 
<P>
 Variables:
  <UL>
  <LI>  tau: Conformal time to evaluate s for.
  <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
  <LI>  theta0: theta0 position to evaluate s for.
  <LI>  h: h parameter (see bianchi data type for explanation).
  <LI>  s: s function value evaluated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_psi"><H3>bianchi_sky_comp_psi</H3></A>
<PRE>private function bianchi_sky_comp_psi (tau, tau0, theta0, h) result (psi)
    real (kind=s2_dp), intent(in) :: tau
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp) :: psi
end function bianchi_sky_comp_psi
</PRE>
 Compute psi variable in bianchi sky simulation. 
<P>
 Variables:
  <UL>
  <LI>  tau: Conformal time to evaluate psi for.
  <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
  <LI>  theta0: theta0 position to evaluate psi for.
  <LI>  h: h parameter (see bianchi data type for explanation).
  <LI>  psi: psi function value evaluated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_c1"><H3>bianchi_sky_comp_c1</H3></A>
<PRE>private function bianchi_sky_comp_c1 (omega0, x) result (c1)
    real (kind=s2_dp), intent(in) :: omega0
    real (kind=s2_dp), intent(in) :: x
    real (kind=s2_dp) :: c1
end function bianchi_sky_comp_c1
</PRE>
 Compute c1 variable in bianchi sky simulation.
<P>
 Variables:
  <UL>
  <LI>  omega0: omega0 parameter (see bianchi data type for explanation).
  <LI>  x: x parameter (see bianchi data type for explanation).
  <LI>  c1: Value of constant c1 computed.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_c2"><H3>bianchi_sky_comp_c2</H3></A>
<PRE>private function bianchi_sky_comp_c2 (sE, zE) result (c2)
    real (kind=s2_dp), intent(in) :: sE
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp) :: c2
end function bianchi_sky_comp_c2
</PRE>
 Compute c2 variable in bianchi sky simulation.
<P>
 Variables:
  <UL>
  <LI>  sE: sE parameter (value of s function computed at emission).
  <LI>  zE: zE parameter (see bianchi data type for explanation).
  <LI>  c2: Value of constant c2 computed.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_c3"><H3>bianchi_sky_comp_c3</H3></A>
<PRE>private function bianchi_sky_comp_c3 (omega0, h) result (c3)
    real (kind=s2_dp), intent(in) :: omega0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp) :: c3
end function bianchi_sky_comp_c3
</PRE>
 Compute c3 variable in bianchi sky simulation.
<P>
 Variables:
  <UL>
  <LI>  omega0: omega0 parameter (see bianchi data type for
    explanation).
  <LI>  h: h parameter (see bianchi data type for
    explanation).
  <LI>  c3: Value of constant c3 computed.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_comp_a"><H3>bianchi_sky_comp_A</H3></A>
<PRE>private function bianchi_sky_comp_A (theta, tauE, tau0, h, zE, c1, c3, quad, N) result (Atheta)
    real (kind=s2_dp), intent(in) :: theta
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: quad
    integer, optional, intent(in) :: N
    real (kind=s2_dp) :: Atheta
    ! Calls: bianchi_error
end function bianchi_sky_comp_A
</PRE>
 Compute A(theta) for Bianchi simulation.
<P>
 Variables:
  <UL>
  <LI>  theta: theta value to eavluate B(theta) for.
   <UL>
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals.
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  Atheta: Value of Atheta term evaluated.
   </UL>
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_bianchi_sky_comp_b"><H3>bianchi_sky_comp_B</H3></A>
<PRE>private function bianchi_sky_comp_B (theta, tauE, tau0, h, zE, c1, c3, quad, N) result (Btheta)
    real (kind=s2_dp), intent(in) :: theta
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: quad
    integer, optional, intent(in) :: N
    real (kind=s2_dp) :: Btheta
    ! Calls: bianchi_error
end function bianchi_sky_comp_B
</PRE>
 Compute B(theta) for Bianchi simulation.
<P>
 Variables:
  <UL>
  <LI>  theta: theta value to eavluate B(theta) for.
   <UL>
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals.
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  Btheta: Value of Btheta term evaluated.
   </UL>
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_bianchi_sky_comp_ia"><H3>bianchi_sky_comp_IA</H3></A>
<PRE>private function bianchi_sky_comp_IA (tauE, tau0, h, zE, c1, c3, l, quad_AB, quad_IAB, N, A_grid) result (IA)
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    integer, intent(in) :: quad_IAB
    integer, optional, intent(in) :: N
    real (kind=s2_dp), optional, intent(in), dimension (0:) :: A_grid
    real (kind=s2_dp) :: IA
    ! Calls: bianchi_error
end function bianchi_sky_comp_IA
</PRE>
 Compute IA_l integral required in Bianchi simulation.
<P>
 Variables:
   <UL>
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute IA_l for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals (required to give to routine used to compute
     A(theta)).
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  IA: Value of IA_l integral evaluated.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_bianchi_sky_comp_ib"><H3>bianchi_sky_comp_IB</H3></A>
<PRE>private function bianchi_sky_comp_IB (tauE, tau0, h, zE, c1, c3, l, quad_AB, quad_IAB, N, B_grid) result (IB)
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    integer, intent(in) :: quad_IAB
    integer, optional, intent(in) :: N
    real (kind=s2_dp), optional, intent(in), dimension (0:) :: B_grid
    real (kind=s2_dp) :: IB
    ! Calls: bianchi_error
end function bianchi_sky_comp_IB
</PRE>
 Compute IB_l integral required in Bianchi simulation.
<P>
 Variables:
   <UL>
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute IB_l for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals (required to give to routine used to compute
     B(theta)).
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  IB: Value of IB_l integral evaluated.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_bianchi_sky_integrand_a"><H3>bianchi_sky_integrand_A</H3></A>
<PRE>private function bianchi_sky_integrand_A (tau, tau0, theta0, h) result (integrand)
    real (kind=s2_dp), intent(in) :: tau
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp) :: integrand
end function bianchi_sky_integrand_A
</PRE>
 Compute integrand of A integral.
<P>
 Variables:
  <UL>
  <LI>  tau: Conformal time to evaluate integrand for.
  <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
  <LI>  theta0: theta0 position to evaluate integrand for.
  <LI>  h: h parameter (see bianchi data type for explanation).
  <LI>  integrand: Integrand value evaluated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_integrand_b"><H3>bianchi_sky_integrand_B</H3></A>
<PRE>private function bianchi_sky_integrand_B (tau, tau0, theta0, h) result (integrand)
    real (kind=s2_dp), intent(in) :: tau
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp) :: integrand
end function bianchi_sky_integrand_B
</PRE>
 Compute integrand of B integral.
<P>
 Variables:
  <UL>
  <LI>  tau: Conformal time to evaluate integrand for .
  <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
  <LI>  theta0: theta0 position to evaluate integrand for.
  <LI>  h: h parameter (see bianchi data type for explanation).
  <LI>  integrand: Integrand value evaluated.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_bianchi_sky_integrand_ia"><H3>bianchi_sky_integrand_IA</H3></A>
<PRE>private function bianchi_sky_integrand_IA (theta, tauE, tau0, h, zE, c1, c3, l, quad_AB, N, A_grid) result (integrand)
    real (kind=s2_dp), intent(in) :: theta
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    integer, optional, intent(in) :: N
    real (kind=s2_dp), optional, intent(in), dimension (0:) :: A_grid
    real (kind=s2_dp) :: integrand
    ! Calls: bianchi_error
end function bianchi_sky_integrand_IA
</PRE>
 Compute integrand of IA_l integral.
<P>
 Notes:
   <UL>
   <LI>  Computation of this integrand required the computation of
     A(theta) and the associated integral requried to compute A(theta).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  theta: theta angle to evaluate integrand for.
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute IA_l for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals (required to give to routine used to compute
     A(theta)).
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  integrand: Integrand value evaluated.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_bianchi_sky_integrand_ib"><H3>bianchi_sky_integrand_IB</H3></A>
<PRE>private function bianchi_sky_integrand_IB (theta, tauE, tau0, h, zE, c1, c3, l, quad_AB, N, B_grid) result (integrand)
    real (kind=s2_dp), intent(in) :: theta
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    integer, optional, intent(in) :: N
    real (kind=s2_dp), optional, intent(in), dimension (0:) :: B_grid
    real (kind=s2_dp) :: integrand
    ! Calls: bianchi_error
end function bianchi_sky_integrand_IB
</PRE>
 Compute integrand of IB_l integral.
<P>
 Notes:
   <UL>
   <LI>  Computation of this integrand required the computation of
     B(theta) and the associated integral requried to compute B(theta).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  theta: theta angle to evaluate integrand for.
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute IB_l for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integrals (required to give to routine used to compute
     B(theta)).
   <LI>  [N]:  Number of terms in use in direct quadrature.
   <LI>  integrand: Integrand value evaluated.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="subroutine_trapzd_a"><H3>trapzd_a</H3></A>
<PRE>private subroutine trapzd_a (func, tau0, theta0, h, a, b, s, n)
    interface func
        function func (tau, tau0, theta0, h) result (integrand)
            real (kind=s2_dp), intent(in) :: tau
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: theta0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    real (kind=s2_dp), intent(INOUT) :: s
    integer, intent(IN) :: n
end subroutine trapzd_a
</PRE>
 Computes nth stage of refinement of extended trapezoidal rule.
 Adapted from numerical recipes for the application at hand.
 For use in computing integrals required to compute A(theta) and
 B(theta).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     This routine computes the nth stage of refinement of an extended 
     trapezoidal rule. func is input as the name of the function to be 
     integrated between limits a and b, also input. When called with
     n=1, the routine returns as s the crudest estimate of 
     int_b^a f(x)dx. Subsequent calls with n=2,3,... (in that sequential
     order) will improve the accuracy of s by adding 2n-2 additional
     interior points. s should not be modified between sequential calls.
   <LI>  Adapted for use in evaluating integrals required to compute
     A <STRONG>or</STRONG> B, (i.e. also takes parameters required to compute these
    integrals).
   <LI>  For our application tau0 and b will be the same, but clear and more
     general to program as two separate variables.
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  theta0: theta0 position to evaluate integral refinement for.
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  s: Value of integral computed to current order.
   <LI>  n: Refinement order.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_qtrap_a"><H3>qtrap_a</H3></A>
<PRE>private function qtrap_a (func, tau0, theta0, h, a, b) result (integral)
    interface func
        function func (tau, tau0, theta0, h) result (integrand)
            real (kind=s2_dp), intent(in) :: tau
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: theta0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    real (kind=s2_dp) :: integral
    ! Calls: bianchi_error, trapzd_a
end function qtrap_a
</PRE>
 Computes the integral of the function func from a to b using the 
 trapezoid method.  Adapted from numerical recipes for the application 
 at hand.
 For use in computing integrals required to compute A(theta) and
 B(theta).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     Returns the integral of the function func from a to b. 
     The parameter EPS should be set to the desired fractional accuracy
     and JMAX so that 2 to the power JMAX-1 is the maximum allowed
     number of steps. Integration is performed by the trapezoidal rule.
   <LI>  Adapted for use in evaluating integrals required to compute
     A <STRONG>or</STRONG> B, (i.e. also takes parameters required to compute these
    integrals).
   <LI>  For our application tau0 and b will be the same, but clear and more
     general to program as two separate variables.!!
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  theta0: theta0 position to evaluate integral refinement for.
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  integral: Value of the evaluated integral.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_qsimp_a"><H3>qsimp_a</H3></A>
<PRE>private function qsimp_a (func, tau0, theta0, h, a, b) result (integral)
    interface func
        function func (tau, tau0, theta0, h) result (integrand)
            real (kind=s2_dp), intent(in) :: tau
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: theta0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: theta0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    real (kind=s2_dp) :: integral
    ! Calls: bianchi_error, trapzd_a
end function qsimp_a
</PRE>
 Computes the integral of the function func from a to b using
 Simpson's rule.  Adapted from numerical recipes for the application 
 at hand.
 For use in computing integrals required to compute A(theta) and
 B(theta).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     Returns the integral of the function func from a to b.
     The parameter EPS should be set to the desired fractional 
     accuracy and JMAX so that 2 to the power JMAX-1 is the maximum
     allowed number of steps. Integration is performed by Simpson's rule.
   <LI>  Adapted for use in evaluating integrals required to compute
     A <STRONG>or</STRONG> B, (i.e. also takes parameters required to compute these
    integrals).
   <LI>  For our application tau0 and b will be the same, but clear and more
     general to program as two separate variables.
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  theta0: theta0 position to evaluate integral refinement for.
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  integral: Value of the evaluated integral.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="subroutine_trapzd_ia"><H3>trapzd_ia</H3></A>
<PRE>private subroutine trapzd_ia (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, s, n, N_quad)
    interface func
        function func (theta, tauE, tau0, h, zE, c1, c3, l, quad, N, AB_grid) result (integrand)
            real (kind=s2_dp), intent(in) :: theta
            real (kind=s2_dp), intent(in) :: tauE
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp), intent(in) :: zE
            real (kind=s2_dp), intent(in) :: c1
            real (kind=s2_dp), intent(in) :: c3
            integer, intent(in) :: l
            integer, intent(in) :: quad
            integer, optional, intent(in) :: N
            real (kind=s2_dp), optional, intent(in), dimension (0:) :: AB_grid
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    real (kind=s2_dp), intent(INOUT) :: s
    integer, intent(IN) :: n
    integer, optional, intent(in) :: N_quad
end subroutine trapzd_ia
</PRE>
 Computes nth stage of refinement of extended trapezoidal rule.
 Adapted from numerical recipes for the application at hand.
 For use in computing integrals IA_l <STRONG>and</STRONG> IB_l (although function
 name is only give the a subscript).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     This routine computes the nth stage of refinement of an extended 
     trapezoidal rule. func is input as the name of the function to be 
     integrated between limits a and b, also input. When called with
     n=1, the routine returns as s the crudest estimate of 
     int_b^a f(x)dx. Subsequent calls with n=2,3,... (in that sequential
     order) will improve the accuracy of s by adding 2n-2 additional
     interior points. s should not be modified between sequential calls.
   <LI>  Adapted for use in evaluating integrals IA_l <STRONG>or</STRONG> IB_l, (i.e. also
     takes parameters required to compute these integrals).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute integral for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integral.
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  s: Value of integral computed to current order.
   <LI>  n: Refinement order.
   <LI>  [N_quad]:  Number of terms in use in direct quadrature.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_qtrap_ia"><H3>qtrap_ia</H3></A>
<PRE>private function qtrap_ia (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, N_quad) result (integral)
    interface func
        function func (theta, tauE, tau0, h, zE, c1, c3, l, quad, N, AB_grid) result (integrand)
            real (kind=s2_dp), intent(in) :: theta
            real (kind=s2_dp), intent(in) :: tauE
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp), intent(in) :: zE
            real (kind=s2_dp), intent(in) :: c1
            real (kind=s2_dp), intent(in) :: c3
            integer, intent(in) :: l
            integer, intent(in) :: quad
            integer, optional, intent(in) :: N
            real (kind=s2_dp), optional, intent(in), dimension (0:) :: AB_grid
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    integer, optional, intent(in) :: N_quad
    real (kind=s2_dp) :: integral
    ! Calls: bianchi_error, trapzd_ia
end function qtrap_ia
</PRE>
 Computes the integral of the function func from a to b using the 
 trapezoid method.  Adapted from numerical recipes for the application 
 at hand.
 For use in computing integrals IA_l <STRONG>and</STRONG> IB_l (although function
 name is only give the a subscript).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     Returns the integral of the function func from a to b. 
     The parameter EPS should be set to the desired fractional accuracy
     and JMAX so that 2 to the power JMAX-1 is the maximum allowed
     number of steps. Integration is performed by the trapezoidal rule.
   <LI>  Adapted for use in evaluating integrals IA_l <STRONG>or</STRONG> IB_l, (i.e. also
     takes parameters required to compute these integrals).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute integral for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integral.
   <LI>  [N_quad]:  Number of terms in use in direct quadrature.
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  integral: Value of the evaluated integral.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 July 2005
<A NAME="function_qsimp_ia"><H3>qsimp_ia</H3></A>
<PRE>private function qsimp_ia (func, tauE, tau0, h, zE, c1, c3, l, quad_AB, a, b, N_quad) result (integral)
    interface func
        function func (theta, tauE, tau0, h, zE, c1, c3, l, quad, N, AB_grid) result (integrand)
            real (kind=s2_dp), intent(in) :: theta
            real (kind=s2_dp), intent(in) :: tauE
            real (kind=s2_dp), intent(in) :: tau0
            real (kind=s2_dp), intent(in) :: h
            real (kind=s2_dp), intent(in) :: zE
            real (kind=s2_dp), intent(in) :: c1
            real (kind=s2_dp), intent(in) :: c3
            integer, intent(in) :: l
            integer, intent(in) :: quad
            integer, optional, intent(in) :: N
            real (kind=s2_dp), optional, intent(in), dimension (0:) :: AB_grid
            real (kind=s2_dp) :: integrand
        end function func
    end interface func
    real (kind=s2_dp), intent(in) :: tauE
    real (kind=s2_dp), intent(in) :: tau0
    real (kind=s2_dp), intent(in) :: h
    real (kind=s2_dp), intent(in) :: zE
    real (kind=s2_dp), intent(in) :: c1
    real (kind=s2_dp), intent(in) :: c3
    integer, intent(in) :: l
    integer, intent(in) :: quad_AB
    real (kind=s2_dp), intent(IN) :: a
    real (kind=s2_dp), intent(IN) :: b
    integer, optional, intent(in) :: N_quad
    real (kind=s2_dp) :: integral
    ! Calls: bianchi_error, trapzd_ia
end function qsimp_ia
</PRE>
 Computes the integral of the function func from a to b using 
 Simpson's rule.  Adapted from numerical recipes for the application 
 at hand.
 For use in computing integrals IA_l <STRONG>and</STRONG> IB_l (although function
 name is only give the a subscript).
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     Returns the integral of the function func from a to b.
     The parameter EPS should be set to the desired fractional 
     accuracy and JMAX so that 2 to the power JMAX-1 is the maximum
     allowed number of steps. Integration is performed by Simpson's rule.
   <LI>  Adapted for use in evaluating integrals required to compute
     A <STRONG>or</STRONG> B, (i.e. also takes parameters required to compute these
    integrals).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  func: "Pointer" to integrand function.
   <LI>  tauE: tauE parameter (see bianchi data type for explanation).
   <LI>  tau0: tau0 parameter (see bianchi data type for explanation).
   <LI>  h: h parameter (see bianchi data type for explanation).
   <LI>  zE: zE parameter (see bianchi data type for explanation).
   <LI>  c1: Bianchi simulation c1 parameter (constant parameter).
   <LI>  c3: Bianchi simulation c3 parameter (constant parameter).
   <LI>  l: Harmonic l to compute integral for.
   <LI>  quad: Integer specifying quadrature rule to use when
     evaluating integral.
   <LI>  [N_quad]:  Number of terms in use in direct quadrature.
   <LI>  a: Lower limit to evalue definite integral for.
   <LI>  b: Upper limit to evalue definite integral for.
   <LI>  integral: Value of the evaluated integral.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_plgndr"><H3>plgndr</H3></A>
<PRE>private function plgndr (l, m, x)
    integer :: l
    integer :: m
    real (kind=s2_dp) :: x
    real (kind=s2_dp) :: plgndr
end function plgndr
</PRE>
 Computes the associated Legendre function for l and m.
  Adapted from numerical recipes 
<P>
 Notes:
   <UL>
   <LI>  Numerical recipies comment:
     Computes the associated Legendre polynomial P_m^l(x).
<P>
   </UL>
 Variables:
   <UL>
   <LI>  l: Legendre function l parameter.
   <LI>  m: Legendre function m parameter.
   <LI>  x: Point to evaluate specified Legendre funtion at.
   </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
<A NAME="function_asinh"><H3>asinh</H3></A>
<PRE>private function asinh (x) result (y)
    real (kind=s2_dp), intent(in) :: x
    real (kind=s2_dp) :: y
end function asinh
</PRE>
 Implementation of asinh, since no intrinsic Fortran function.
<P>
 Variables:
  <UL>
  <LI>  x: Asinh argument.
  <LI>  y: Asinh result.
  </UL>
<P>
<STRONG>Author:</STRONG> J. D. McEwen
<P>
<STRONG>Version:</STRONG> 0.1 June 2005
</HTML>
